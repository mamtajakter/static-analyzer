
/*
 * Quack, a simple language for beginning compiler writers
 *
 */

%skeleton "lalr1.cc"
%require  "3.0"

/* The following section "code requires" finds its way into
 * calc.tab.hxx, so definitions and declarations in this block
 * can be imported into the lexer.
 */
%code requires{
  namespace yy {
    class Lexer;  /* Generated by reflex with namespace=yy lexer=Lexer */
  }

  #include "ASTNode.h"  // Abstract syntax tree

}


%locations
  /* %define parse.trace --- can't do this and also --debug on command line */

%parse-param { yy::Lexer& lexer }  /* Construct parser object with lexer */
%parse-param { AST::ASTNode** root }  /* To pass AST root back to driver */

%code{
    #include "lex.yy.h"
    #undef yylex
    #define yylex lexer.yylex  /* Within bison's parse() we should invoke lexer.yylex(), not the global yylex() */
    void debug(AST::ASTNode* n);

}

/* -------------------------------------------------------
 * Semantic values: Tokens and Abstract Syntax Tree
 * -------------------------------------------------------
 */

%union {
    /* Tokens */
    int   num;
    char*  str;
    /* Abstract syntax tree values */
    AST::ASTNode* node;  // Most general class
    AST::Ident* ident;   // Identifiers are used in many places
    AST::LExpr* l_expr;
    AST::Load*  load;
    AST::Statement* statement;
    AST::Expr* expr;
    // Alas, looks like we need a member per sequence type
    AST::Actuals* actuals;
    AST::Block* block;
    AST::Classes* classes;
    AST::Class* clas;
    AST::Typecase* typecase;
    AST::Type_Alternatives* type_alternatives;
    AST::Type_Alternative* type_alternative;
    AST::Methods* methods;
    AST::Method* method;
    AST::Formals* formals;
    AST::Formal* formal;
}

/* -----------------------------------------
 * Associate non-terminals with classes in
 * the abstract syntax tree (AST)
 * ------------------------------------------
 */
%type <ident> ident opt_return_ident opt_cls_extends
%type <l_expr> l_expr
%type <expr> expr
%type <statement> statement
%type <node> pgm
%type <classes> classes
%type <clas> clas
%type <block> statements statement_block opt_elif_parts
%type <actuals> actual_args actual_args_nonempty
%type <typecase> typecase
%type <type_alternatives> type_alt_opt
%type <type_alternative> type_alt
%type <methods> methods
%type <method> method
%type <formals> formal_args formal_args_delim
%type <formal> formal_arg

/* -------------------------------------------
 * Tokens.
 * -------------------------------------------
 */
/* Keywords (no semantic values) */
%token CLASS
%token DEF
%token EXTENDS
%token IF ELIF ELSE
%token WHILE
%token BOO
%token RETURN
%token TYPECASE

 /* Multi-character punctuation (no semantic values) */
%token ATLEAST ATMOST EQUALS
%token AND OR NOT

/* Identifiers (semantic value is the identifier name) */
%type <str> IDENT
%token IDENT

/* Literals (semantic value is the literal value) */
%token INT_LIT STRING_LIT
%type <str> STRING_LIT
%type <num> INT_LIT

/* Precedence of arithmetic operators
 * and deref
 */

%left AND OR
%left NOT
%nonassoc ATMOST '>'
%nonassoc ATLEAST '<'
%left EQUALS
%left '+' '-'
%left '*' '/'
%precedence NEG   /* Negation */
%left '.'         /*  because a.b.c*d is ((a.b).c)*d */
%%

/* *************************************
 * Program Structure
 * *************************************
 */

/* A Quack program is a sequence of classes followed by some
 * statements.  The statements are the main program.
 */

pgm:	classes  statements
        { $$ = new AST::Program(*$1, *$2);
          // std::cerr << "Transmitting root to driver\n";
          *root = $$; // Transmit tree back to driver
          // std::cerr << "Transmitted root to driver\n";
        }
        ;

/* Zero or more classes;
 *
 */
classes:   classes clas     {  $$ = $1; $$->append($2); }
       |   /* empty */      {  $$ = new AST::Classes(); }
       ;

/* Zero or more statements
 * (although a program with zero statements is pretty boring)
 */
statements: statements statement  { $$ = $1;
                                    $$->append($2);
                                  }
          | /* empty */           { $$ = new AST::Block(); }
          ;


/* A block is demarcated by curly braces.   */
statement_block: '{' statements BOO '}'
  {  $$ = $2; }
  ;

/* *************************************
 * Class Structure
 * *************************************
 */

clas: CLASS ident '(' formal_args ')' opt_cls_extends '{' statements methods '}'
               /*{ $$ = new AST::Class(*$2, *$6, *(new AST::Method(*$2, *$4, *(new AST::Ident("Nothing")), *$8)), *$9); }*/
               { $$ = new AST::Class(*$2, *$6, *(new AST::Method(*$2, *$4, *$2, *$8)), *$9); }
               ;

opt_cls_extends: EXTENDS ident { $$ = new AST::Ident(*$2); }
               | /* empty */ { $$ = new AST::Ident("Obj"); }
               ;

formal_args: formal_args_delim { $$ = $1; }
           | /* empty */ { $$ = new AST::Formals(); }
           ;

formal_args_delim: formal_args_delim ',' formal_arg { $$ = $1; $$->append($3); }
                 | formal_arg { $$ = new AST::Formals(); $$ -> append($1); }
                 ;

formal_arg: ident ':' ident { $$ = new AST::Formal(*$1, *$3); }
          ;

/* *************************************
 * Method Declarations
 * *************************************
 */
methods: methods method { $$ = $1; $$->append($2); }
       | /* empty */ { $$ = new AST::Methods(); }
       ;

method: DEF ident '(' formal_args ')' opt_return_ident statement_block
        { $$ = new AST::Method(*$2, *$4, *$6, *$7); }
      ;

opt_return_ident: ':' ident { $$ = $2; }
                | /* empty */ { $$ = new AST::Ident("none"); }
                ;

/* *************************************
 * Statements: Control structure
 * *************************************
 */

/* Conditional:
 *   if x < 0
 *     { x = x + 1; }
 *   elif x > 10
 *     { x = x - 3; }
 *   else
 *     { x = 0; }
 */


statement: IF expr statement_block  opt_elif_parts
	     { $$ = new AST::If(*$2, *$3, *$4); }
	     | WHILE expr statement_block
         { $$ = new AST::While(*$2, *$3); }
	     ;

opt_elif_parts:  ELIF expr statement_block  opt_elif_parts
             { $$ = new AST::Block();
               $$->append(new AST::If(*$2, *$3, *$4));
             }
             |   ELSE statement_block
             { $$ = $2; }
             | /* empty */
             { $$ = new AST::Block(); }
             ;

statement: expr ';' { $$ = $1; }
         ;

/* *************************************
 * Statements: Assignment
 * *************************************
 */


statement: l_expr '=' expr ';'
     { $$ = new AST::Assign(*$1, *$3); }
     ;

statement: l_expr ':' ident '=' expr ';'
    {
      $$ = new AST::AssignDeclare(*$1, *$5, *$3);
    }
    ;

/* l_expr: Things we can assign to, or call.
 * (Evaluate to a location; type checking determines
 * what type is compatible.)
 * Including:
 *    Simple local variable assignments like x = expr;
 *    Fields of the current object, this.x = expr;
 *    Methods of any object, (3+4).PRINT, sqr.translate(1,1).translate
 */
l_expr: IDENT { $$ =  new AST::Ident($1); }
      | expr '.' ident { $$ = new AST::Dot(*$1, *$3); }
      ;


/* *************************************
 * Expressions
 * (right-hand expressions, i.e., expressions
 *  that evaluate to values rather than locations)
 * *************************************
 */

/* An l_expr is also an expr; we load the value
 * from that address.  Even though this is a unit production,
 * it corresponds to an operation (loading a value) in the
 * semantics, so we give it a node in the AST.
 */
expr: l_expr { $$ = new AST::Load(*$1); } ;

/* Values can also be denoted by literals */
expr: STRING_LIT { $$ = new AST::StrConst($1); }
    | INT_LIT    { $$ = new AST::IntConst($1); }
    ;

/* The binary operations.  We will use precedence
 * rather than expanding out the expression grammar.
 * We order by precedence and indicate associativity.
 *
 * Binary and unary operations are implemented by
 * desugaring:  Abstract syntax is method calls.
 */
expr:  expr '*' expr   { $$ = AST::Call::binop("TIMES", *$1, *$3); }
    | expr '/' expr    { $$ = AST::Call::binop("DIVIDE", *$1, *$3); }
    |  expr '+' expr   { $$ = AST::Call::binop("PLUS", *$1, *$3); }
    |  expr '-' expr   { $$ = AST::Call::binop("MINUS", *$1, *$3); }
    |  '-' expr  %prec NEG  {
                              auto zero = new AST::IntConst(0);
                              $$ = AST::Call::binop("MINUS", *zero, *$2);
                            }
    | '(' expr ')' { $$ = $2; }
    /* Comparisons */
    | expr EQUALS   expr     { $$ = AST::Call::binop("EQUALS", *$1, *$3); }
    | expr ATLEAST   expr     { $$ = AST::Call::binop("ATLEAST", *$1, *$3); }
    | expr ATMOST   expr     { $$ = AST::Call::binop("ATMOST", *$1, *$3); }
    | expr '<'   expr     { $$ = AST::Call::binop("<", *$1, *$3); }
    | expr '>'   expr     { $$ = AST::Call::binop(">", *$1, *$3); }

    /* Boolean expressions are NOT syntactic sugar */
    | expr AND   expr     { $$ = new AST::And(*$1, *$3); }
    | expr OR   expr     { $$ = new AST::Or(*$1, *$3); }
    | NOT   expr     { $$ = new AST::Not(*$2); }
    ;

/* Method calls are indicated in the usual way
 * as obj.method(args)
 *
 * Precedence note:
 *   a+b.c(i) is a+(b.c(i))
 *   a.b.c(i) is (a.b).c(i)
 * We make calls on an expr, not an lexpr ---
 *   we need an actual value to look up the
 *   method in.  The only exception is class
 *   constructors ... but we can treat the
 *   class as an rvalue also.
 *
 */

expr: expr '.' ident '(' actual_args ')'
 { $$ = new AST::Call(*$1, *$3, *$5); }
 ;
actual_args: /*empty*/  { $$ = new AST::Actuals(); }
   | actual_args_nonempty { $$ = $1; };
actual_args_nonempty:
            actual_args_nonempty ',' expr { $$ = $1; $$->append($3); }
          | expr  { $$ = new AST::Actuals(); $$->append($1); }
          ;

/* Constructor calls */
expr: ident '(' actual_args ')'
   { $$ = new AST::Construct(*$1, *$3); }
   ;

/* *************************************
 * Return
 * *************************************
 */

statement: RETURN expr ';' { $$ = new AST::Return(*$2); }
         | RETURN ';' { $$ = new AST::Return(*new AST::Ident("none")); }
         ;

/* *************************************
 * Typecase
 * *************************************
 */

statement: typecase { $$ = $1; }
         ;

typecase: TYPECASE expr '{' type_alt_opt '}'
        { $$ = new AST::Typecase(*$2, *$4); }
        ;

type_alt_opt: type_alt_opt type_alt { $$ = $1; $$->append($2); }
            | /* empty */ { $$ = new AST::Type_Alternatives();}
            ;

type_alt: ident ':' ident statement_block
        { $$ = new AST::Type_Alternative(*$1, *$3, *$4); }
        ;

/* *************************************
 * Identifiers
 * *************************************
 */

ident: IDENT { $$ = new AST::Ident($1); } ;

%%

void yy::parser::error(const location_type& loc, const std::string& msg)
{
  report::error_at(loc, msg);
}

void debug(AST::ASTNode* n) {
    std::cout << "*** Building: " << n->str() << std::endl;
    }
